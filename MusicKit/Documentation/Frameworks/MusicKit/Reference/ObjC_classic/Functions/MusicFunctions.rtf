{\rtf0\ansi{\fonttbl\f0\fnil Times-Roman;\f1\ftech Symbol;\f3\fmodern Courier;}
\paperw16220
\paperh12580
\margl120
\margr0
{\colortbl;\red0\green0\blue0;}
\f0\b0\i0\ulnone\ql\fs24\fi0\li0\gray0\fc0\cf0\up0\dn0 Release 2.0  Copyright 
\f1 „
\f0 1990 by NeXT Computer, Inc.  All Rights Reserved.\
\
Updates for Release 4.0  Copyright 
\f1 „
\f0 1993 by CCRMA, Stanford University.  All Rights Reserved.\
\

\pard\tx2100\tx2620\tx3120\tx3620\fs16\li2100\fc0\cf0 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

\pard\b\li100\fc0\cf0 \
\
\
\

\fs36 Music Kit Functions\

\fs16 \

\fs36\li1100 MKAdjustFreqWithPitchBend() 
\f1\b0 Æ
\f0  
\b See MKKeyNumToFreq()\

\fs16 \
\
\
\
\

\fs36 MKAmpToMidi(), MKAmpAttenuationToMidi(), MKMidiToAmp(), MKMidiToAmpAttenuation(), MKMidiToAmpWithSensitivity(), MKMidiToAmpAttenuationWithSensitivity()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Translate loudness from the Music Kit to MIDI\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/Note.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 int 
\b MKAmpToMidi(
\b0 double 
\i amp
\b\i0 )\

\b0 int 
\b MKAmpAttenuationToMidi(
\b0 double 
\i amp
\b\i0 )\

\b0 double 
\b MKMidiToAmp(
\b0 int 
\i midiValue
\b\i0 )\

\b0 double 
\b MKMidiToAmpAttenuation(
\b0 int 
\i midiValue
\b\i0 )\

\b0 double 
\b MKMidiToAmpWithSensitivity(
\b0 int 
\i midiValue
\i0 , double
\b  
\b0\i sensitivity
\b\i0 )\

\b0 double 
\b MKMidiToAmpAttenuationWithSensitivity(
\b0 int 
\i midiValue
\i0 , double
\b  
\b0\i sensitivity
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 These functions help you convert Music Kit amplitude values to MIDI values and vice versa.\

\fs16 \

\fs28 MKAmpToMidi()
\b0  and 
\b MKMidiToAmp()
\b0  are complementary
\b  
\b0 functions that provide a non-linear mapping of amplitude to MIDI values, as described below:\

\fs16 \

\pard\tx3120\tx7400\tx8660\fs28\li2620\fc0\cf0 	
\b MKAmpToMidi(
\b0 double 
\i amp
\b\i0 )
\b0 	returns		64 + (64 * log10 
\i amp
\i0 )\
	
\b MKMidiToAmp(
\b0 int 
\i midiValue
\b\i0 )
\b0 	returns 	10.0(
\i midiValue
\i0 -64)/64\

\fs16 \

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc0\cf0 This provides a scale in which an amp of 0.0 yields a MIDI value of 0, 1.0 produces 64, and 10.0 gives 127.  \

\fs16 \

\b\fs28 MKAmpAttenuationToMidi()
\b0  and 
\b MKMidiToAmpAttenuation() 
\b0 are similarly complementary, and the curve of the mapping is the same as in the foregoing, but the scale is attenuated by a factor of ten:  0.0 maps to 0, 0.1 to 64, and 1.0 to 127. \

\fs16 \

\b\fs28 MKMidiToAmpWithSensitivity()
\b0  and 
\b MKMidiToAmpAttenuationWithSensitivity()
\b0  are modifications of the similarly named MIDI-to-amp and MIDI-to-ampAttenuation functions in which an additional sensitivity value, nominally in the range 0.0 to 1.0, is used to scale the product of the conversion. \

\fs16 \

\fs28 The multiplicity of conversion functions is provided in deference to the nature of MIDI volume computation:  Unlike DSP-bound amplitude values (specifically, the value of the MK_amp parameter), effective MIDI volume is a combination of a number of parameters, the primary ones being velocity, main volume control, and foot pedal control.  While the velocity value generated by a MIDI instrument is almost never at the maximum, the other values often are.  In general, you use 
\b MKAmpToMidi()
\b0  and 
\b MKMidiToAmp()
\b0  (or 
\b MKMidiToAmpWithSensitivy()
\b0 ) to convert between amplitude and velocity.  The amp attenuation functions are used to generate a value from or to be applied to one of MIDI controller parameters.\

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKAmpAttenuationToMidi() 
\f1\b0 Æ
\f0  
\b See MKAmpToMidi()\

\fs16 \

\fs36 MKCancelMsgRequest() 
\f1\b0 Æ
\f0  
\b See MKNewMsgRequest() \

\fs16 \

\fs36 MKClearTrace() 
\f1\b0 Æ
\f0  
\b See
\b0  
\b MKSetTrace() \

\fs16 \
\
\
\
\

\fs36 MKdB()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Convert decibels to amplitude\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/musickit.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 double 
\b MKdB(
\b0 double 
\i dB
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 MKdB()
\b0  returns an amplitude value (within the range [0.0, 1.0]) converted from its argument specified as decibels.  The returned value can be used to set a UnitGenerator's amplitude, for example.  The value is converted using the following formula:\

\fs16 \

\fs28 	
\i amplitude 
\i0 = 10.0 
\i dB
\i0 /20.0 \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKError(), MKSetErrorProc(), MKSetErrorStream(), MKErrorStream()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Handle Music Kit errors\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/errors.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 id 
\b MKError(
\b0 char *
\i msg
\b\i0 )\

\b0 void 
\b MKSetErrorProc(
\b0 void 
\i (*errProc)(char *msg)
\b\i0 )\

\b0 void 
\b MKSetErrorStream(
\b0 NXStream *
\i aStream
\b\i0 )\

\b0 NXStream *
\b MKErrorStream()\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 These functions define the Music Kit's error handling mechanism.  
\b MKError()
\b0  is used to signal an error.  It calls the current Music Kit error function, set through 
\b MKSetErrorProc()
\b0 , to which it passes the single argument 
\i msg
\i0 .  If the user hasn't declared an error function, then 
\i msg
\i0  is written to the Music Kit error stream, as set through 
\b MKSetErrorStream()
\b0 .  The default error stream is open to
\b  stderr
\b0 .
\b   MKErrorStream()
\b0  returns a pointer to the current Music Kit error stream.  Note that you 
\i shouldn't
\i0  use 
\b stderr
\b0  as the error stream if you're running a separate-threaded performance.\

\fs16 \

\fs28 A number of error codes represented by integer constants are provided by the Music Kit and listed in 
\b <musickit/errors.h>
\b0 .  If the Music Kit itself generates an error, the global system variable 
\b errno
\b0  is set to one of these error codes.  If you call 
\b MKError()
\b0  from your application, 
\b errno
\b0  isn't set.  \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKErrorStream() 
\f1\b0 Æ
\f0\b  See MKError()\

\fs16 \

\fs36 MKFinishPerformance() 
\f1\b0 Æ
\f0  
\b See MKGetTime()\

\fs16 \

\fs36 MKFreqToKeyNum() 
\f1\b0 Æ
\f0  
\b See MKKeyNumToFreq() \

\fs16 \

\fs36 MKGetDeltaT() 
\f1\b0 Æ
\f0  
\b See
\b0  
\b MKGetTime()\

\fs16 \

\fs36 MKGetDeltaTTime() 
\f1\b0 Æ
\f0  
\b See MKGetTime()\

\fs16 \

\fs36 MKGetDeltaTMode() 
\f1\b0 Æ
\f0\b  See MKGetTime() \

\fs16\fc1\cf1 \

\fs36\fc0\cf0 MKGetEnvelopeClass() 
\f1\b0 Æ
\f0\b  See MKSetNoteClass() \

\fs16 \

\fs36 MKGetNamedObject() 
\f1\b0 Æ
\f0  
\b See MKNameObject()\

\fs16 \

\fs36 MKGetNoDVal() 
\f1\b0 Æ
\f0\b  See MKIsNoDVal() \

\fs16 \

\fs36 MKGetNoteParAsDouble() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \

\fs36 MKGetNoteParAsInt() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \

\fs36 MKGetNoteParAsObject() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \

\fs36 MKGetNoteParAsString() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \

\fs36 MKGetNoteParAsStringNoCopy() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \

\fs36 MKGetNoteParAsWaveTable() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \

\fs36 MKGetObjectName() 
\f1\b0 Æ
\f0  
\b See MKNameObject()\

\fs16 \

\fs36 MKGetPartClass() 
\f1\b0 Æ
\f0\b  See MKSetNoteClass() \

\fs16 \

\fs36 MKGetPartialsClass() 
\f1\b0 Æ
\f0\b  See MKSetNoteClass() \

\fs16 \

\fs36 MKGetPreemptDuration() 
\f1\b0 Æ
\f0\b  See MKSetPreemptDuration() \

\fs16 \

\fs36 MKGetSamplesClass() 
\f1\b0 Æ
\f0\b  See MKSetNoteClass() \

\fs16 \
\
\
\
\

\fs36 MKGetTime(), MKGetDeltaT(), MKSetDeltaT(), MKGetDeltaTTime(), MKFinishPerformance(), MKSetTime(), MKSetLowDeltaTThreshold(), MKSetHighDeltaTThreshold(), MKSetDeltaTMode(), MKGetDeltaTMode\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Set and get Music Kit time values\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/musickit.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 double 
\b MKGetTime()\

\b0 double 
\b MKGetDeltaT()\

\b0 void
\b  MKSetDeltaT(
\b0 double 
\i val
\b\i0 )\

\b0 double 
\b MKGetDeltaTTime()\

\b0 double 
\b MKSetTime(
\b0 double 
\i newTime
\b\i0 )\

\b0 void 
\b MKFinishPerformance()\

\b0\fc1\cf1 void 
\b MKSetLowDeltaTThreshold(
\b0 double 
\i percentageOfDeltaT
\b\i0 )
\b0 \
void 
\b MKSetHighDeltaTThreshold(
\b0 double 
\i percentageOfDeltaT
\b\i0 )\

\b0 extern
\b  void MKSetDeltaTMode(
\b0 int
\b  
\b0\i newMode
\b\i0 )\

\b0 extern
\b  int MKGetDeltaTMode(
\b0 void
\b )\

\b0 \

\fs16\fi0\li2100\fc0\cf0 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 MKGetTime()
\b0  returns the current time, in seconds, during a Music Kit performance.   In a conducted performance (the norm), this is the same as [Conductor time]. \

\fs16 \

\b\fs28 MKSetDeltaT()
\b0  sets a performance's delta time in seconds.  The delta time value is used in one of two ways, depending on the delta time "mode", which is set with 
\b MKSetDeltaTMode()
\b0 .  In MK_DELTAT_DEVICE_LAG mode, deltaT is added into the timestamps of DSP and MIDI messages, thus imposing a time lag between the Music Kit and these devices.  If, on the other hand, the delta time mode is MK_DELTAT_SCHEDULER_ADVANCE, then deltaT is the amount by which the Music Kit Conductor attempts to run ahead of the devices.  In either case, the lag is sometimes necessary to allow the Music Kit sufficient compute time while maintaining rhythmic integrity.  Effective delta time values can be quite small; for an application that requires real-time response, a delta time of as much as 10 milliseconds (0.01 seconds) is tolerable.  Delta time only affects devices that are timed.  In addition, in order for the delta time value to be valid, the performance and the devices must be started at (virtually) the same time.  That is, send 
\b [orchestra run]
\b0  and 
\b [midi run]
\b0  immediately before sending 
\b [Conductor startPerformance]
\b0 ;\

\fs16 \

\b\fs28 MKGetDeltaT()
\b0  returns the delta time value, in seconds. The meaning of delta time depends on whether the performance is clocked or unclocked.  In a clocked performance, the Conductor tries to stay 
\i approximately
\i0  delta time seconds ahead of the devices (e.g. DSP). In an unclocked performance, Conductor tries to stay 
\i at least
\i0  delta time seconds ahead of the devices. Delta time has an effect only if the device is in timed mode.\

\fs16 \

\b\fs28 MKGetDeltaTTime()
\b0  returns the sum of the values returned by 
\b MKGetTime()
\b0  and 
\b MKGetDeltaT()
\b0 .  \

\fs16 \

\b\fs28 MKSetTime()
\b0  and 
\b MKFinishPerformance()
\b0  are provided to set the performance time and to end a performance, respectively, 
\i but only in the case of a performance that doesn't use the Conductor class. 
\i0  
\i  
\i0 During a conducted performance, 
\b MKSetTime()
\b0  has no effect and 
\b MKFinishPerformance()
\b0  is the same as sending 
\b finishPerformance
\b0  to the Conductor class.    Precisely, 
\b MKFinishPerformance()
\b0  his the effect of evaluating the Conductor's "after performance" queue of messages, which in turn tells the Performers and Instruments that the performance is finished. \
\

\b\fc1\cf1 MKSetLowDeltaTThreshold() 
\b0 and 
\b MKSetHighDeltaTThreshold() 
\b0 controls the high and low watermark for the delta time notification mechanism. For example, to receive a message when the Conductor has fallen behind such that the effective delta time is less than 1/4 of the value of MKGetDeltaT(), you'd call 
\b MKSetLowDeltaTThreshold(.25);
\b0   Similarly, to receive a message when the Conductor has recovered such that the effective delta time is more than 3/4 of the value of 
\b MKGetDeltaT()
\b0 , you'd call 
\b MKSetHighDeltaTThreshold(.75);  
\b0 This mechanism allows you to receive a warning when the Conductor is about to fall out of real time, due to heavy computation.   For example, you might want to automatically reduce the tempo in this case.  The notification itself is sent to the Conductor class' delegate object.  See Conductor.h for further details.  \

\pard\b\fs16\li1100\fc0\cf0 \

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc1\cf1 MKSetDeltaTMode();  
\b0 Sets the delta time mode to one of MK_DELTAT_DEVICE_LAG or MK_DELTAT_SCHEDULER_ADVANCE .    The default is MK_DELTAT_DEVICE_LAG.\

\pard\b\fs16\li1100\fc0\cf0 \

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc1\cf1 MKGetDeltaTMode();  
\b0 Returns the delta time mode.\

\pard\b\fs16\li1100\fc0\cf0 \
\
\
\

\fs36 MKHighestPar() 
\f1\b0 Æ
\f0\b  See MKIsNoteParPresent() \
\
MKInitParameterIteration() 
\f1\b0 Æ
\f0  
\b See MKIsNoteParPresent()\

\fs16 \
\
\
\
\

\fs36 MKIsNoDVal(), MKGetNoDVal()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Test for no 
\b double
\b0  value\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/noDVal.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 int 
\b MKIsNoDVal(
\b0 double 
\i value
\b\i0 )\

\b0 double 
\b MKGetNoDVal()\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 A number of Music Kit functions and methods 
\b0 query for and return 
\b double
\b0 -valued quantities, such as the values of parameters and time tags.  By convention, the value MK_NODVAL is returned if the queried-for value hasn't been set; however, you can't test for this value directly.  You must use the function 
\b MKIsNoDVal()
\b0  instead, passing as the argument the value that you wish to test.  The function returns nonzero if 
\i value
\i0  is equal to MK_NODVAL and 0 if it isn't.\

\fs16 \

\b\fs28 MKGetNoDVal() 
\b0 returns the no-
\b double
\b0 -value indicator.  You use this function as the return value for functions and methods of your own design in which you wish to indicate that a 
\b double
\b0 -valued quantity hasn't been set.  For convenience, MK_NODVAL is defined as this function.  \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\

\fs36 MKIsNoteParPresent(), MKInitParameterIteration(),  MKNextParameter(), MKHighestPar()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Query for a Note's parameters\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/Note.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 BOOL 
\b MKIsNoteParPresent(
\b0 Note *
\i aNote
\i0 , int 
\i par
\b\i0 )\

\b0 void *
\b MKInitParameterIteration(
\b0 Note *
\i aNote
\b\i0 )\

\b0 int 
\b MKNextParameter(
\b0 Note *
\i aNote
\b\i0 , 
\b0 void *
\i iterationState
\b\i0 )\

\b0 int 
\b MKHighestPar(
\b0 void
\b )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 MKIsNoteParPresent()
\b0  returns YES or NO as the parameter 
\i par
\i0  within the Note 
\i aNote
\i0  is or isn't present; a parameter is considered present only if it's been given a value.  The function is equivalent to Note's 
\b isParPresent:
\b0  method.  Unless the mere existence of the parameter is significant, you would follow a call to 
\b MKIsNoteParPresent()
\b0  with a parameter value retrieval function, such as 
\b MKGetNoteParAsDouble()
\b0 :\

\fs16 \

\pard\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\f3\fs24\li3120\fc0\cf0 double freq;\
\
/* Get the value of MK_freq only if the parameter has been set. */\
if (MKIsNoteParPresent(aNote, MK_freq))\
\{\
	freq = MKGetParAsDouble(aNote, MK_freq);\
	... /* do something with freq */\
\}\
\

\pard\tx3120\tx3620\tx4120\f0\b\fs28\li2620\fc0\cf0 MKInitParameterIteration()
\b0  and 
\b MKNextParameter()
\b0  work together to return, one by one, the full complement of a Note's parameter identifiers.  
\b MKInitParameterIteration()
\b0  primes its Note argument for successive calls to 
\b MKNextParameter()
\b0 , each of which retrieves the next parameter in the Note.  When all the parameters have been visited, 
\b MKNextParameter()
\b0  returns the value MK_noPar.  The pointer returned by 
\b MKInitParameterIteration()
\b0  must be passed as the 
\i iterationState
\i0  argument to 
\b MKNextParameter()
\b0 .  Keep in mind that 
\b MKNextParameter()
\b0  returns parameter identifiers; you still must retrieve the value of the parameter.  An example for your delight:\

\fs16 \

\pard\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\f3\fs24\li3120\fc0\cf0 /* Initialize the iteration state for the desired Note. */\
void *aState = MKInitParameterIteration(aNote);\
int par;\
\
/* Get the parameters until the Note is exhausted. */\
while ((par = MKNextParameter(aNote, aState)) != MK_noPar)\
\{\
	/* Operate on the parameters of interest. */\
	switch (par) \
	\{\
		case MK_freq:\
			/* Get the value of MK_freq and apply it. */\
			... \

\pard\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\li3120\fc0\cf0 			break;\
		case MK_amp:\
			/* Get the value of MK_amp and apply it. */\
			... \

\pard\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx3720\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4320\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx4920\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx5540\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6140\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx6740\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7340\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx7960\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx8560\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9160\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx9760\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10380\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx10980\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx11580\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12180\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\tx12800\li3120\fc0\cf0 			break;\
		default: \
			/* Ignore all other parameters. */\
			break;  \
	\}\
\}\
\

\pard\tx3120\tx3620\tx4120\f0\fs28\li2620\fc0\cf0 In essence, the two examples do the same thing:  They find and operate on parameters of interest.  Which methodology to adopt–whether to test for the existence of  particular parameters as in the first example, or to retrieve the identifiers of all present parameters as in the second–depends on how ™saturated∫ the Note is with interesting parameters.  If you only want a couple of parameters then it's generally more efficient to call 
\b MKIsNoteParPresent()
\b0  for each of them.  However, if you're interested in most–or what you assume to be most–of a Note's parameters (as is usually the case for a reasonably sophisticated SynthPatch, for example), then it's probably faster to iterate over all the parameters through 
\b MKNextParameter()
\b0 .  \
\

\b MKHighestPar() 
\b0 returns the parameter tag of the highest numbered parameter.  This can be used, for example, to print the names of all known parameters as follows:\
	\

\f3\fs24 		for (i=0; i<=MKHighestPar(); i++) \
			printf([Note parNameForTag:i]);\

\f0\fs28 \

\fs16 \

\pard\li2100\fc0\cf0 \

\fs28 SEE ALSO\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 MKGetNoteParAsDouble()
\b0 , 
\b MKGetNoteParAsInt()
\b0 , etc., 
\b MKIsNoDVal()\

\fs16 \

\pard\li1100\fc0\cf0 \
\
\
\

\fs36 MKIsTraced() 
\f1\b0 Æ
\f0  
\b See MKSetTrace()\

\fs16 \
\
\
\
\

\fs36 MKKeyNumToFreq(), MKFreqToKeyNum(), MKTranspose(), MKAdjustFreqWithPitchBend()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Convert and adjust frequencies\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/TuningSystem.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 double 
\b MKKeyNumToFreq(
\b0 MKKeyNum 
\i keyNum
\b\i0 )\

\b0 double
\b  MKTranspose(
\b0 double
\i  freq
\i0 , double
\i  semitones
\b\i0 )\

\b0 MKKeyNum 
\b MKFreqToKeyNum(
\b0 double 
\i freq
\i0 , int *
\i bendPtr, 
\i0 double
\i  sensitivity
\b\i0 )\

\b0 double 
\b MKAdjustFreqWithPitchBend(
\b0 double
\i  freq
\i0 , int
\i  pitchBend, 
\i0 double 
\i sensitivity
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 MKKeyNumToFreq()
\b0  returns the frequency that corresponds to the given key number, based upon the mapping of key numbers to frequencies in the
\i  installed tuning system
\i0  (see the TuningSystem class description in Chapter 2 for more information on the instralled tuning system).  \

\fs16 \

\b\fs28 MKTranspose()
\b0  returns the frequency that results from transposing 
\i freq
\i0  by the specified number of semitones.  A negative 
\i semitones
\i0  value transposes down; a fractional value can be used to transpose by less than a semitone.  The transposition afforded by this function is always in twelve-tone equal-temperament, regardless of the installed tuning system, as computed by the formula\

\fs16 \

\fs28 	result = 
\i freq
\i0  * 2 
\i semitones
\i0 /12.0 \

\fs16 \

\b\fs28 MKFreqToKeyNum()
\b0  returns the key number that most closely corresponds to the given frequency.  The amount of pitch bend needed to temper the pitch of the key number in order to match the actual frequency is returned by reference in 
\i bendPtr
\i0 .  This value is computed using the 
\i sensitivity
\i0  argument as the number of semitones by which the key number is tempered given a maximum pitch bend; in other words, you supply the maximum pitch bend by passing in a 
\i sensitivity
\i0  value, and the function returns, in 
\i bendPtr
\i0 , the amount of the bend that's needed.  The value of 
\i bendPtr
\i0  is a 14-bit MIDI pitch bend number; you would use it to set the value of a Note's MK_pitchBend parameter (assuming that you use 
\i sensitivity
\i0  as value of the Note's MK_pitchBendSensitivity parameter).\

\fs16 \

\b\fs28 MKAdjustFreqWithPitchBend()
\b0  returns the frequency that results when 
\i freq
\i0  is tempered by 
\i pitchBend 
\i0 worth
\i  
\i0 of
\i  sensitivity 
\i0 semitones, where 
\i pitchBend
\i0  is, again, a 14-bit MIDI pitch bend number. \

\fs16 \

\pard\li2100\fc0\cf0 \

\fs28 RETURN\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 MKKeyNumToFreq()
\b0  returns MK_NODVAL if 
\i keyNum
\i0  is out of bounds (less than 0 or greater than 127).   Use 
\b MKIsNoDVal()
\b0  to check for MK_NODVAL.\

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKMidiToAmp() 
\f1\b0 Æ
\f0  
\b See MKAmpToMidi()\

\fs16 \

\fs36 MKMidiToAmpAttenuation() 
\f1\b0 Æ
\f0  
\b See MKAmpToMidi()\

\fs16 \

\fs36 MKMidiToAmpWithSensitivity() 
\f1\b0 Æ
\f0\b  See MKAmpToMidi()\

\fs16 \

\fs36 MKMidiToAmpAttenuationWithSensitivity() 
\f1\b0 Æ
\f0\b  See MKAmpToMidi()\

\fs16 \
\
\
\
\

\fs36  MKNameObject(),MKGetObjectName(), MKRemoveObjectName(), MKGetNamedObject()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Identify and return objects by name\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/musickit.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 BOOL 
\b MKNameObject(
\b0 char *
\i name
\i0 , id 
\i object
\b\i0 )\

\b0 const char *
\b MKGetObjectName(
\b0 id
\i  object
\b\i0 )\

\b0 id 
\b MKRemoveObjectName(
\b0 id
\i  object
\b\i0 )\

\b0 id 
\b MKGetNamedObject(
\b0 char *
\i name
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 The Music Kit provides a global naming mechanism that lets you identify and locate objects by name.  While names are primarily used in reading and writing scorefiles, any object–even a non-Music Kit object–can be named.  Names needn't be unique; more than one object can be given the same name.  However, a single object can have but one name at a time.  \

\fs16 \

\b\fs28 MKNameObject()
\b0  sets 
\i object
\i0 's name to a copy of 
\i name
\i0  and returns YES.  If the object already has a name, then this function does nothing and returns 
\b NO.  \

\fs16 \

\fs28 MKGetObjectName()
\b0  returns its argument's name, or NULL if it isn't named.  The returned value is read-only and shouldn't be freed by the caller.  \

\fs16 \

\b\fs28 MKRemoveObjectName()
\b0  removes its argument's name (if any) and returns 
\b nil
\b0 .  \

\fs16 \

\b\fs28 MKGetNamedObject()
\b0  returns the first object in the name table that has the name 
\i name.  \

\fs16 \

\pard\b\i0\li1100\fc0\cf0 \
\
\
\

\fs36 MKNewMsgRequest(), MKScheduleMsgRequest(), MKRepositionMsgRequest(), MKCancelMsgRequest(), MKRescheduleMsgRequest()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Create and manipulate Conductor message requests\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/Conductor.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 MKMsgStruct 
\b *MKNewMsgRequest(
\b0 double
\i  timeOfMsg
\i0 , SEL
\i  whichSelector
\i0 , id
\i  destinationObject
\i0 , int
\i  argCount, ...
\b\i0 )\

\b0 void
\b  MKScheduleMsgRequest(
\b0 MKMsgStruct *
\i aMsgStructPtr
\i0 , id
\i  conductor
\b\i0 )\

\b0 MKMsgStruct *
\b MKRepositionMsgRequest(
\b0 MKMsgStruct *
\i aMsgStructPtr
\b\i0 , \

\b0\fi0 double 
\i newTimeOfMsg
\b\i0 )\

\b0\fi-520 MKMsgStruct *
\b MKCancelMsgRequest(
\b0 MKMsgStruct *
\i aMsgStructPtr
\b\i0 )\

\b0 MKMsgStruct *
\b MKRescheduleMsgRequest(
\b0 MKMsgStruct *
\i aMsgStructPtr, 
\i0 id 
\i conductor, 
\i0 double 
\i newTimeOfMsg, 
\i0 SEL 
\i whichSelector, 
\i0 id 
\i destinationObject, 
\i0 int 
\i argCount, ...
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 These functions let you enqueue message requests with a Conductor object.  The  MKMsgStruct structure encapulates a message request; it consists of a method selector and its arguments, the recipient of the message, and the time that the message should be sent.  A selector can take a maximum of two 4-byte arguments.  You should never modify the fields of a MKMsgStruct structure directly.  \

\fs16 \

\b\fs28 MKNewMsgRequest()
\b0  creates and returns a new MKMsgStruct.  
\i timeOfMsg
\i0  is the time in beats from the beginning of the performance that the message will be sent, 
\i whichSelector
\i0  is the selector, 
\i destinationObject
\i0  is the recipient of the message, and 
\i argCount
\i0  is the number of arguments to the selector followed by the arguments themselves separated by commas.   \

\fs16 \

\fs28 After you've created a message request structure, you schedule it with a Conductor by calling
\b  MKScheduleMsgRequest()
\b0\i .
\i0 \

\fs16 \

\fs28 If you want to move a message request within a Conductor's queue you call the 
\b MKRepositionMsgRequest()
\b0  function.  The specified MKMsgStruct is moved to the time given by 
\i newTimeOfMsg.  
\i0 You should note that the MKMsgStruct that you pass as the 
\i aMsgStructPtr
\i0  argument may be replaced with a new structure that's returned by the function
\i .  
\i0 To make sure you don't keep around a pointer to an obsolete struct, call this function as follows:  \

\fs16 \

\f3\fs24 	/* Reposition and prime aMsgReq for additional functions calls. */\
	aMsgReq = MKRepositionMsgRequest(aMsgReq, 3.0);\

\fs16 \

\f0\b\fs28 MKCancelMsgRequest()
\b0  cancels the given message request and frees the structure pointed to by 
\i aMsgStructPtr.   
\i0 Be sure not to cancel an already-canceled request.  To make sure you don't do that, you should assign the returned value of the function (NULL) to the value you pass.  Example of use:\
\

\f3\fs24 	aMsgReq = MKCancelMsgRequest(aMsgReq);\
	/* aMsgReq is now NULL */\

\f0\i\fs28 \

\fs16 \

\b\i0\fs28 MKRescheduleMsgRequest()
\b0  is a convenience function that cancels the structure pointed to by 
\i aMsgStructPtr
\i0 , and then creates and schedules a new request according to the arguments.  The new MKMsgStruct is returned.\

\fs16 \

\pard\li2100\fc0\cf0 \

\fs28 RETURN\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 MKNewMsgRequest()
\b0  and 
\b MKRescheduleMsgRequest()
\b0  return 
\i NULL if argCount
\i0  is greater than 2.  
\b MKCancelMsgRequest()
\b0  always returns NULL.  \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKNextParameter() 
\f1\b0 Æ
\f0  
\b See MKIsNoteParPresent()\

\fs16 \
\
\
\
\

\fs36 MKNoteTag(), MKNoteTags()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Create note tags\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/Note.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 unsigned 
\b int MKNoteTag()\

\b0 unsigned 
\b int MKNoteTags(
\b0 unsigned 
\i int n
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 Note tags are positive integers used to identify a series of Note objects as part of the same musical event, gesture, or phrase.  A common use of note tags is to create a noteOn/noteOff pair by giving the two Notes the same note tag value.  \

\fs16 \

\b\fs28 MKNoteTag()
\b0  returns a note tag value that's guaranteed to be unique across your entire application.  
\b MKNoteTags()
\b0  returns the first of a block of 
\i n
\i0  unique, contiguous note tags.  \

\fs16 \

\fs28 You should never create note tag values except through these functions.\

\fs16 \

\pard\li2100\fc0\cf0 \

\fs28 RETURN\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 Returns MAXINT (the maximum note tag value) if a sufficient number of note tags aren't available, an unlikely occurrence.  \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKNoteTags() 
\f1\b0 Æ
\f0\b  MKNoteTag()\

\fs16 \

\fs36 MKRemoveObjectName() 
\f1\b0 Æ
\f0  
\b See MKNameObject() \

\fs16 \

\fs36 MKRepositionMsgRequest() 
\f1\b0 Æ
\f0  
\b See MKNewMsgRequest()\

\fs16 \

\fs36 MKRescheduleMsgRequest() 
\f1\b0 Æ
\f0  
\b See MKNewMsgRequest()\

\fs16 \

\fs36 MKScheduleMsgRequest() 
\f1\b0 Æ
\f0\b  See MKNewMsgRequest() \

\fs16 \

\fs36 MKSetDeltaT() 
\f1\b0 Æ
\f0  
\b See MKGetTime() \

\fs16 \

\fs36 MKSetDeltaTMode() 
\f1\b0 Æ
\f0\b  See MKGetTime() \

\fs16\fc1\cf1 \

\fs36\fc0\cf0 MKSetEnvelopeClass() 
\f1\b0 Æ
\f0\b  See MKSetNoteClass() \

\fs16 \

\fs36 MKSetErrorStream() 
\f1\b0 Æ
\f0\b  See MKError() \

\fs16 \

\fs36 MKSetHighDeltaTThreshold 
\f1\b0 Æ
\f0  
\b See MKGetTime() \

\fs16\fc1\cf1 \

\fs36\fc0\cf0 MKSetLowDeltaTThreshold 
\f1\b0 Æ
\f0  
\b See MKGetTime() 
\fs16\fc1\cf1 \
\

\fs36\fc0\cf0 MKSetNoteParToEnvelope() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \

\fs36 MKSetNoteParToInt() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \

\fs36 MKSetNoteParToObject() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \

\fs36 MKSetNoteParToString() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \

\fs36 MKSetNoteParToWaveTable() 
\f1\b0 Æ
\f0\b  See MKSetNoteParToDouble() \

\fs16 \
\
\
\
\

\fs36 MKSetNoteParToDouble(), MKSetNoteParToInt(), MKSetNoteParToString(),  MKSetNoteParToEnvelope(), MKSetNoteParToWaveTable(), MKSetNoteParToObject(), MKGetNoteParAsDouble(),  MKGetNoteParAsInt(), MKGetNoteParAsString(),  MKGetNoteParAsStringNoCopy(), MKGetNoteParAsEnvelope(), MKGetNoteParAsWaveTable(), MKGetNoteParAsObject()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Set and retrieve a Note's parameters\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/Note.h>\

\fs16 \

\pard\fs28\fi-520\li3120\fc0\cf0 Note *MKSetNoteParToDouble(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\i0 , double
\b  
\b0\i value
\b\i0 )\
Note *MKSetNoteParToInt(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\i0 , int
\b  
\b0\i value
\b\i0 )\
Note *MKSetNoteParToString(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\i0 , char *
\i value
\b\i0 )\
Note *MKSetNoteParToEnvelope(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\i0 , Envelope *
\i value
\b\i0 )\
Note *MKSetNoteParToWaveTable(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\i0 ,WaveTable *
\i value
\b\i0 )\
Note *MKSetNoteParToObject(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\i0 , Object *
\i value
\b\i0 )\

\b0 \

\b double MKGetNoteParAsDouble(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\b\i0 )\
int MKGetNoteParAsInt(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\b\i0 )\
char *MKGetNoteParAsString(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\b\i0 )\
char *MKGetNoteParAsStringNoCopy(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\b\i0 )\
Envelope *MKGetNoteParAsEnvelope(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\b\i0 )\
WaveTable *MKGetNoteParAsWaveTable(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\b\i0 )\
Object *MKGetNoteParAsObject(
\b0 Note *
\i aNote
\i0 , int
\b  
\b0\i par
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 These functions set and retrieve the values of a Note's parameters, one parameter at a time. They're equivalent to the similarly named Note methods
\b ; for example, the function call \

\fs16 \

\pard\tx3720\tx4320\tx4920\tx5540\tx6140\tx6740\tx7340\tx7960\tx8560\tx9160\tx9760\tx10380\tx10980\tx11580\tx12180\tx12800\f3\fs24\li3120\fc0\cf0 MKSetNoteParToDouble(aNote, MK_freq, 440.0) \
\

\pard\tx3120\tx3620\tx4120\f0\b0\fs28\li2620\fc0\cf0 is the same as the message:\

\fs16 \

\pard\tx3720\tx4320\tx4920\tx5540\tx6140\tx6740\tx7340\tx7960\tx8560\tx9160\tx9760\tx10380\tx10980\tx11580\tx12180\tx12800\f3\b\fs24\li3120\fc0\cf0 [aNote setPar:MK_freq toDouble:440.0] \
\

\pard\tx3120\tx3620\tx4120\f0\b0\fs28\li2620\fc0\cf0 As ever, calling a function is somewhat faster than sending a message, thus you may want to use these functions, rather than the corresponding methods, if you're examining and manipulating barrels of parameters, or in situations where speed is crucial.  See the method descriptions in the Note class for more information (by implication) regarding the operations of these functions.\

\fs16 \

\pard\li2100\fc0\cf0 \

\fs28 RETURN\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 The 
\b MKSetParTo...()
\b0  functions return 
\i aNote
\i0 , or 
\b nil
\b0  if either 
\i aNote
\i0  is 
\b nil
\b0  or 
\i par
\i0  isn't a valid parameter identifier. \

\fs16 \

\fs28 The 
\b MKGetParAs...()
\b0  functions return the
\i  
\i0 requested value, or 
\b nil
\b0  if either 
\i aNote
\i0  is 
\b nil
\b0  of 
\i par
\i0  isn't a valid parameter identifier.  If the parameter value hasn't been set, an indicative value is returned:\

\fs16 \

\pard\tx3120\tx7660\tx8160\b\fs28\fc0\cf0 	Function	No-set return value\

\b0 	MKGetNoteParAsInt()	MAXINT\
	MKGetNoteParAsDouble()	MK_NODVAL (check with 
\b MKIsNoDVal()
\b0 )\
	MKGetNoteParAsString()	
\f3\fs24 ""\

\f0\fs28 	MKGetNoteParAsStringNoCopy()	
\f3\fs24 ""\
	
\f0\fs28 MKGetNoteParAsEnvelope()	
\b nil\

\f3\b0\fs24 	
\f0\fs28 MKGetNoteParAsWaveTable()	
\b nil\

\f3\b0\fs24 	
\f0\fs28 MKGetNoteParAsObject()	
\b nil\

\pard\b0\fs16\li2100\fc0\cf0 \
\

\fs28 SEE ALSO\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 MKIsNoteParPresent()
\b0 , 
\b MKInitParameterIteration()
\b0 , 
\b MKNextParameter()
\b0 , 
\b MKIsNoDVal()\

\fs16 \

\pard\li1100\fc0\cf0 \
\
\
\

\fs36 MKSetNoteClass(), MKSetPartClass(), MKSetEnvelopeClass(), MKSetPartialsClass(), MKSetSamplesClass(), MKGetNoteClass(), MKGetPartClass(), MKGetEnvelopeClass(), MKGetPartialsClass(), MKGetSamplesClass()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Set and retrieve scorefile creation classes\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/Note.h>\

\fs16 \

\pard\fs28\fi-520\li3120\fc0\cf0 BOOL MKSetNoteClass(
\b0 Note *
\i noteSubclass
\b\i0 )\
BOOL MKSetPartClass(
\b0 Part *
\i partSubclass
\b\i0 )\
BOOL MKSetEnvelopeClass(
\b0 Envelope *
\i envelopeSubclass
\b\i0 )\
BOOL MKSetPartialsClass(
\b0 Partials *
\i partialsSubclass
\b\i0 )\
BOOL MKSetSamplesClass(
\b0 Samples *
\i samplesSubclass
\b\i0 )\

\b0 \

\b Note *MKGetNoteClass()\
Part *MKGetPartClass()\
Envelope *MKGetEnvelopeClass()\
Partials *MKGetPartialsClass()\
Samples *MKGetSamplesClass()\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 When you read a scorefile into your application, some number of objects are automatically created.  Specifically, these objects are instances of Note, Part, Envelope, Partials, and Samples.  You can supply your own classes from which these instances are created through these functions.  The one restriction is that the class that you set must be a subclass of the original class; for example, the class that you pass the argument to 
\b MKSetNoteClass()
\b0  must be a subclass of Note.\

\fs16 \

\fs28 The 
\b MKGet
\i Class
\i0 Class() 
\b0 functions return the requested classes as set through the  functions above.\

\fs16 \

\pard\li2100\fc0\cf0 \

\fs28 RETURN\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 MKSet
\i Class
\i0 Class()
\b0  returns NO if the argument isn't a subclass of 
\b\i Class
\b0\i0 ; otherwise it returns YES. \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKSetPartClass() 
\f1\b0 Æ
\f0\b  See MKSetNoteClass() \

\fs16 \

\fs36 MKSetPartialsClass() 
\f1\b0 Æ
\f0\b  See MKSetNoteClass() \

\fs16 \
\
\
\
\

\fs36 MKSetPreemptDuration(), MKGetPreemptDuration()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Set the SynthPatch preemption time\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/musickit.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 void
\b  MKSetPreemptDuration(
\b0 double 
\i seconds
\b\i0 )\

\b0 double
\b  MKGetPreemptDuration()\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 During a performance, DSP resources can become scarce; it's sometimes necessary to preempt active SynthPatches in order to synthesize new Notes.  This preemption is handled by SynthInstrument objects.  But rather than simply yank the rug from under an active SynthPatch, a certain amount of time is given to allow the patch to ™wind down∫ before it's killed in order to prevent clicks.  By default, this grace period, or ™preempt duration∫, is 0.006 seconds–not a lot of time but enough to avoid snapping the SynthPatch's envelopes.  You can set the preempt duration yourself through 
\b MKSetPreemptDuration()
\b0 .  Preempt duration is global to an application; it's current value is retrieved through 
\b MKGetPreemptDuration()
\b0 . \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKSetSamplesClass() 
\f1\b0 Æ
\f0\b  See MKSetNoteClass() \

\fs16 \
\
\
\
\

\fs36 MKSetScorefileParseErrorAbort()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Set the scorefile error threshhold\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/musickit.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 void
\b  MKSetScorefileParseErrorAbort(
\b0 int 
\i threshholdCount
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 As a scorefile is read into an application, errors sometimes occur:  Time tags may be out of order; undeclared or mistyped names may pop up in the middle of the file.  The Music Kit keeps a count of these errors for each file it reads.  If the error count for a particular file exceeds the threshhold set as the 
\i threshholdCount
\i0  argument to this function, the scorefile parsing is aborted and the file is closed (if the Music Kit opened it itself).  The default limit is ten errors.\

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKSetTime() 
\f1\b0 Æ
\f0  
\b See MKGetTime() \

\fs16 \
\
\
\
\

\fs36 MKSetTrace(), MKClearTrace(), MKIsTraced()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Trouble-shoot the Music Kit \

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/errors.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 unsigned 
\b int MKSetTrace(
\b0 int 
\i traceCode
\b\i0 )\

\b0 unsigned 
\b int MKClearTrace(
\b0 int
\i  traceCode
\b\i0 )\

\b0 BOOL 
\b MKIsTraced(
\b0 int 
\i traceCode
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 To aid in debugging, the Music Kit is peppered with activity-tracing messages that print to 
\b stderr
\b0  if but asked.The trace messages are divided into eight categories, represented by the following codes:\

\fs16 \

\pard\tx3120\tx7660\tx8920\tx14200\b\fs28\li2620\fc0\cf0 	Code	Value	Meaning\

\b0 	MK_TRACEORCHALLOC	1	DSP resource allocation\
	MK_TRACEPARS	2	Application-defined parameters\
	MK_TRACEDSP	4	DSP manipulation\
	MK_TRACEMIDI	8	MIDI manipulation\
	MK_TRACEPREEMPT	16	SynthPatch preemption\
	MK_TRACESYNTHINS	32	SynthInstrument mechanations\
	MK_TRACESYNTHPATCH	64	SynthPatch library messages\
	MK_TRACEUNITGENERATOR	128	UnitGenerator library messages\
	MK_TRACECONDUCTOR	256	Conductor time setting messages\
	MK_TRACEDSPARRAYS	512	DSP array-setting messages\

\fs16 \

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc0\cf0 To enable a set of messages, you pass a trace code to the 
\b MKSetTrace()
\b0  function.  You can enable more than one set with a single function call by bitwise-or'ing the codes.   Clearing a trace is done similarly, by passing codes to 
\b MKClearTrace()
\b0 .  The 
\b MKIsTraced()
\b0  function returns YES or NO as the argument code is or isn't currently traced.  These functions should only be used while you're debugging and fine-tuning your application.  \

\fs16 \

\fs28 You should note that the codes given above are 
\b #define
\b0 'd as their corresponding values and so can be used only when you call one of these functions within an application–they can't be used in a symbolic debugger such as 
\b gdb
\b0 .  For this reason, the integer values themselves are also given; you must use the integer values to enable and disable a set of trace messages from within a debugger.  \
\
The debug flags are listed below with some of the possible messages you may see when using them.   Note that not all possible messages are included.\

\fs16 \

\pard\b\li2100\fc0\cf0 \

\fs28 MK_TRACEORCHALLOC\

\pard\tx3120\tx3620\tx4120\b0\li2620\fc0\cf0 The Orchestra allocation messages inform you of DSP resource allocation.  The most important of these have to do with SynthPatch, UnitGenerator, and Synth Data allocation.  When a SynthPatch is allocated, one of the following messages is printed:\

\fs16 \

\fs28 	
\f3\fs24 "allocSynthPatch returns 
\i SynthPatchClass_SynthPatchId
\f0\i0\fs28 "\
	
\f3\fs24 "allocSynthPatch building 
\i SynthPatchClass_SynthPatchId
\i0 ..."\
	"allocSynthPatch can't allocate 
\i SynthPatchClass
\i0 "\

\fs16 \

\f0\fs28 The first of these signifies that an appropriate SynthPatch object was found.  The second means that a new object was created.  The third denotes an inability to construct the requested object because of insufficient DSP resources.  As a SynthPatch's UnitGenerators are connected, the following message is printed:\

\fs16 \

\fs28 	
\f3\fs24 "allocSynthPatch connectsContents of 
\i SynthPatchClass_SynthPatchId
\f0\i0\fs28 "\

\fs16 \

\fs28 When a SynthPatch is deallocated and when it's freed, respectively, the following are printed:\

\fs16 \

\fs28 	
\f3\fs24 "Returning 
\i SynthPatchClass_SynthPatchId
\i0  to avail pool."\
	"Freeing 
\i SynthPatchClass_SynthPatchId
\i0 "\

\fs16 \

\f0\fs28 A UnitGenerator can be allocated without reference to other UnitGenerators, or it can be positioned before, after, or between other objects.  Examples:\

\fs16 \

\fs28 	
\f3\fs24 "allocUnitGenerator looking for a 
\i UGClass
\i0 ."\
	"allocUnitGenerator looking for a 
\i UGClass
\i0  before 
\i UGClass_UGid
\i0 "\
	"allocUnitGenerator looking for a 
\i UGClass
\i0  after 
\i UGClass_UGid
\i0 "\
	"allocUnitGenerator looking for a 
\i UGClass
\i0  after 
\i UGClass_UGid
\i0 \
		and before 
\i UGClass_UGid
\i0 "\

\fs16 \

\f0\fs28 If a new UnitGenerator is built, the addresses (relocation or ™Reloc∫) and sizes (resources or ™Reso∫) of the allocated DSP resources are given:\

\fs16 \

\fs28 	
\f3\fs24 "Reloc: pLoop 
\i address
\i0 , xArg 
\i address
\i0 , yArg 
\i address
\i0 , lArg 
\i address
\i0 ,\
		xData 
\i address
\i0 , yData 
\i address
\i0 , pSubr 
\i address
\i0 "\
	"Reso: pLoop 
\i size
\i0 , xArg 
\i\fc1\cf1 size
\i0\fc0\cf0 , yArg 
\i\fc1\cf1 size
\i0\fc0\cf0 , lArg 
\i\fc1\cf1 size
\i0\fc0\cf0 , xData 
\i\fc1\cf1 size
\i0\fc0\cf0 ,\
		yData 
\i\fc1\cf1 size
\i0\fc0\cf0 , pSubr 
\i\fc1\cf1 size
\i0\fc0\cf0 , time 
\i\fc1\cf1 orchestraLoopDuration
\i0\fc0\cf0 "\

\fs16 \

\f0\fs28 As the UnitGenerator search (or allocation) succeeds or fails, one of the following is printed:\

\fs16 \

\fs28 	"
\f3\fs24 allocUnitGenerator returns
\f0\fs28  
\f3\i\fs24 UGClass_UGid
\f0\i0\fs28 "\
	
\f3\fs24 "Allocation failure: Can't allocate before specified ug."\
	"Allocation failure. DSP error."\
	"Allocation failure. Not enough computeTime."\
	"Allocation failure. Not enough 
\i\fc1\cf1 memorySegment
\i0\fc0\cf0  memory."\

\fs16 \

\f0\fs28 Allocating a SynthData generates the first and then either the second or third of these messages:\

\fs16 \

\fs28 	
\f3\fs24 "allocSynthData: looking in segment 
\i\fc1\cf1 memorySegment
\i0\fc0\cf0  for size 
\i\fc1\cf1 size
\i0\fc0\cf0 ."\
	"allocSynthData returns 
\i\fc1\cf1 memorySegment
\i0\fc0\cf0  address of length 
\i\fc1\cf1 size
\i0\fc0\cf0 ."\
	"Allocation failure: No more offchip data memory."\

\fs16 \

\f0\fs28 When you install shared data, the following is printed: \

\fs16 \

\fs28 	"
\f3\fs24 Installing shared data 
\i\fc1\cf1 keyObjectName
\i0\fc0\cf0  in segment 
\i\fc1\cf1 memorySegment
\i0\fc0\cf0 .
\f0\fs28 "\

\fs16 \

\fs28 During allocation of UnitGenerators and SynthDatas, existing resources might be compacted.  Compaction can cause free UnitGenerators and unreferenced shared data to be garbage collected, and active UnitGenerators to be relocated:\

\fs16 \

\fs28 	
\f3\fs24 "Compacting stack."\
	"Copying arguments."\
	"Copying p memory."\
	"Garbage collecting freed unit generator UGClass_UGid"\
	"Moving 
\i\fc1\cf1 UGClass_UGid
\i0\fc0\cf0 ."\
	"NewReloc: pLoop 
\i\fc1\cf1 address
\i0\fc0\cf0 , xArg 
\i\fc1\cf1 address
\i0\fc0\cf0 , yArg 
\i\fc1\cf1 address
\i0\fc0\cf0 , lArg 
\i\fc1\cf1 address
\i0\fc0\cf0 ."\
	"Garbage collecting unreferenced shared data."\
	"No unreferenced shared data found."\

\fs16 \

\pard\f0\b\li2100\fc0\cf0 \

\fs28 MK_TRACEDSP\

\pard\tx3120\tx3620\tx4120\b0\li2620\fc0\cf0 The DSP-trace messages give you details of how the DSP is being used.  For example, when a UnitGenerator is allocated, the following message is printed among the search-build-return messages given above:\

\fs16 \

\fs28 	
\f3\fs24 "Loading 
\i\fc1\cf1 UGClass_UGid
\i0\fc0\cf0  as UG 
\i\fc1\cf1 ugNum
\i0\fc0\cf0 ."\

\fs16 \

\f0\fs28 Unit Generators are given integer numbers for debugging purposes.  These numbers simply count up.  Numbers are not recycled.   Thus, an example of an actual "Loading..." message would be:\
\
	
\f3\fs24 "Loading Out1aUGx_0x43100 as UG3."\

\f0\fs28 \
The most important of the DSP-trace messages reflect the setting of a UnitGenerator's memory arguments.  A memory argument takes either an address value or a data value.  When you set an address-valued argument, the following is printed:\

\fs16 \

\fs28 	
\f3\fs24 "Setting 
\i\fc1\cf1 argName
\i0\fc0\cf0  of 
\i\fc1\cf1 UGugNum_Class
\i0\fc0\cf0  to 
\i memSegment memNum
\i0  (
\fc1\cf1 0x
\i address
\i0 )
\fc0\cf0 ."\

\fs16 \

\f0\i\fs28 argName 
\i0 is the argument name in the source DSP (.asm) file.  \
\
A data-valued arguments is either a 24-bit or 48-bit word; separate functions (and cover methods) are defined for setting the two sizes of arguments.  The following messages are printed as the ™correct∫ function is used to set an argument's value:\

\fs16 \

\f3\fs24 	"Setting 
\i\fc1\cf1 argName
\i0\fc0\cf0  of 
\i\fc1\cf1 UGugNum_Class
\i0\fc0\cf0  to datum 
\i\fc1\cf1 value
\i0\fc0\cf0 ."\
	"Setting 
\i\fc1\cf1 argName
\i0\fc0\cf0  of 
\i\fc1\cf1 UGugNum_Class
\i0\fc0\cf0  to long: \
		
\i\fc1\cf1 hi wd value
\i0\fc0\cf0  and 
\i\fc1\cf1 low wd value
\i0\fc0\cf0 ."\
\

\fs16 \

\f0\fs28 A 24-bit argument that's set with the long-setting function and vice versa produce these messages, respectively:\

\fs16 \

\f3\fs24 	"Setting (L-just, 0-filled) 
\i\fc1\cf1 argName
\i0\fc0\cf0  of 
\i\fc1\cf1 UGugNum_Class
\i0\fc0\cf0  to datum 
\i\fc1\cf1 value
\i0\fc0\cf0 ."\
	"Setting 
\i\fc1\cf1 argName
\i0\fc0\cf0  of 
\i\fc1\cf1 UGugNum_Class
\i0\fc0\cf0  to: 
\i\fc1\cf1 value
\i0\fc0\cf0 "\

\fs16 \

\f0\fs28 If an argument is declared as optimizable, the following is printed when the optimization obtains:\

\fs16 \

\fs28 	"
\f3\fs24 Optimizing away poke of 
\i\fc1\cf1 argName
\i0\fc0\cf0  of 
\i\fc1\cf1 UGugNum_Class
\i0\fc0\cf0 ."\

\fs16 \

\f0\fs28 SynthData allocation doesn't actually involve the DSP; the address of the memory that will be allocated on the DSP is computed, but the state of the DSP itself doesn't change until data is loaded into the SynthData:\

\fs16 \

\fs28 	
\f3\fs24 "Loading array into 
\i\fc1\cf1 memorySegment
\i0\fc0\cf0  
\i\fc1\cf1 memNum
\i0\fc0\cf0  [
\i\fc1\cf1 lowAddr-highAddr
\i0\fc0\cf0 ]."\
	"Loading constant value into 
\i\fc1\cf1 memorySegement
\i0\fc0\cf0  
\i\fc1\cf1 memNum
\i0\fc0\cf0  [
\i\fc1\cf1 lowAddr-highAddr
\i0\fc0\cf0 ]."\

\fs16 \

\f0\fs28 Here 
\i\fc1\cf1 memNum
\i0\fc0\cf0  is an integer assigned for debugging purposes.  
\i\fc1\cf1 memorySegment
\i0\fc0\cf0  if one of xData, yData, xPatch or yPatch.  When an array is loaded, the loaded values are printed if 
\b MK_DSPTRACEARRAYS
\b0  has been enabled.  Example:\

\fs16\fc1\cf1 \

\fs28\fc0\cf0 	
\f3\fs24 "Loading array into 
\i\fc1\cf1 xPatch
\i0\fc0\cf0  
\i\fc1\cf1 4
\i0\fc0\cf0  [
\i\fc1\cf1 0x412-0x418
\i0\fc0\cf0 ]."\

\f0\fs16\fc1\cf1 \

\fs28\fc0\cf0 Clearing a SynthData's memory produces the following:\

\fs16 \

\f3\fs24 	"Clearing 
\i memorySegment
\i0  
\i memNum
\i0  [
\i lowAddr-highAddr
\i0 ]."\

\fs16 \

\f0\fs28 DSP manipulations that are performed as an atomic unit are bracketed by the messages:\

\fs16 \

\fs28 	
\f3\fs24 "<<< Begin orchestra atomic unit "\
	"end orchestra atomic unit.>>> "\

\fs16 \

\pard\f0\b\li2100\fc0\cf0 \

\fs28 MK_TRACESYNTHINS\

\pard\tx3120\tx3620\tx4120\b0\li2620\fc0\cf0 The SynthInstrument messages are printed when a SynthInstrument object receives Notes, and as it finds or creates SynthPatches to realize these Notes.  \

\fs16 \

\fs28 If a received Note's note tag is active or inactive, or if its note type is mute, the following are printed, respectively:\

\fs16 \

\f3\fs24 	"SynthInstrument receives note for active notetag stream 
\i noteTag
\i0  \
		at time 
\i time
\i0 ."\
	"SynthInstrument receives note for new notetag stream 
\i\fc1\cf1 noteTag
\i0\fc0\cf0  \
		at time 
\i\fc1\cf1 time
\i0\fc0\cf0 ."\
	"SynthInstrument receives mute Note at time 
\i\fc1\cf1 time
\i0\fc0\cf0 ."\

\fs16 \

\f0\fs28 SynthPatch allocation is noted 
\i only
\i0  if the SynthInstrument is in auto-allocation mode:\

\fs16 \

\f3\fs24 	"SynthInstrument creates patch 
\i\fc1\cf1 synthPatchId
\i0\fc0\cf0  at time 
\i\fc1\cf1 time
\i0\fc0\cf0  \
		for tag 
\i\fc1\cf1 noteTag
\i0\fc0\cf0 ."\

\fs16 \

\f0\fs28 However, SynthPatch reuse and preemption produce the following messages, respectively, regardless of the SynthInstrument's allocation mode:\

\fs16 \

\fs28  
\f3\fs24 	"SynthInstrument uses patch 
\i\fc1\cf1 synthPatchId
\i0\fc0\cf0  at time 
\i\fc1\cf1 time
\i0\fc0\cf0  \
		for tag 
\i\fc1\cf1 noteTag
\i0\fc0\cf0 ."\
	"SynthInstrument preempts patch 
\i\fc1\cf1 synthPatchId
\i0\fc0\cf0  at time 
\i\fc1\cf1 time
\i0\fc0\cf0  \
		for tag 
\i\fc1\cf1 noteTag
\i0\fc0\cf0 ."\

\fs16 \

\f0\fs28 If a SynthPatch of the correct PatchTemplate isn't found and can't be allocated, an alternative is used; barring that, the SynthInstrument omits the Note:\

\fs16 \

\f3\fs24 	"No patch of requested template was available. \
		Using alternative template."\
	"SynthInstrument omits note at time 
\i\fc1\cf1 time
\i0\fc0\cf0  for tag 
\i\fc1\cf1 noteTag
\i0\fc0\cf0 ."\

\fs16 \

\f0\b\li2100 \

\fs28 MK_TRACEPREEMPT\

\b0\li2620 These are a subset of the SynthInstrument messages that deal with SynthPatch preemption and Note omission:\

\fs16 \

\f3\fs24 	"SynthInstrument preempts patch 
\i\fc1\cf1 synthPatchId
\i0\fc0\cf0  at time 
\i\fc1\cf1 time
\i0\fc0\cf0  \
		for tag noteTag."\
	"SynthInstrument omits note at time 
\i\fc1\cf1 time
\i0\fc0\cf0  for tag 
\i\fc1\cf1 noteTag
\i0\fc0\cf0 .\

\fs16 \

\f0\b\li2100 \

\fs28 MK_TRACEMIDI\

\b0\li2620 The following are printed as ill-formed Note objects are converted to MIDI messages: \

\fs16 \

\f3\fs24 	"NoteOn missing a noteTag at time 
\i\fc1\cf1 time
\i0\fc0\cf0 "\
	"NoteOff missing a note tag at time 
\i\fc1\cf1 time
\i0\fc0\cf0 "\
	"NoteOff for noteTag which is already off at time 
\i\fc1\cf1 time
\i0\fc0\cf0 "\
	™PolyKeyPressure with invalid noteTag or missing keyNum: time 
\i\fc1\cf1 time
\i0\fc0\cf0 ;"\

\fs16 \

\f0\b\li2100 \

\fs28 MK_TRACESYNTHPATCH \

\b0\li2620 This referes to SynthPatch Library messages.  When debugging SynthPatches, you may also want to turn on TRACEUNITGENERATOR.\
\

\b\li2100 MK_TRACEUNITGENERATOR\

\b0\li2620 This refers to UnitGenerator library messages.  f the sine ROM, which resides in Y memory, is requested by a UnitGenerator's X-space memory argument, the following appears:\

\fs16 \

\f3\fs24 	"X-space oscgaf cannot use sine ROM at time
\f0\fs28  
\f3\i\fs24 time
\i0 ."
\f0\fs28  \

\fs16 \

\fs28 If insufficient DSP memory is available to load a WaveTable of the requested length, the following is printed:\

\fs16 \

\f3\fs24 	"Insufficient wavetable memory at time 
\i\fc1\cf1 time
\i0\fc0\cf0 .  \
		Using smaller table length 
\i\fc1\cf1 newLength
\i0\fc0\cf0 ."\

\pard\f0\b\fs16\li2100\fc0\cf0 \

\fs28 MK_TRACEPARS\

\pard\tx3120\tx3620\tx4120\b0\li2620\fc0\cf0 By tracing MK_TRACEPARS, you're informed when an application-defined parameter is created:\

\fs16 \

\f3\fs24 	"Adding new parameter 
\i\fc1\cf1 parameterName
\i0\fc0\cf0 "\

\fs16 \

\f0\li2100 \

\pard\b\fs28\li2100\fc0\cf0 MK_TRACECONDUCTOR\

\pard\tx3120\tx3620\tx4120\b0\li2620\fc0\cf0 By tracing MK_TRACECONDUCTOR, a message giving the time in seconds is printed whenever time advances:\

\fs16 \

\f3\fs24 	"t 4.1"\

\fs16 \

\f0\li2100 \

\fs28 RETURN\

\b\li2620 MKSetTrace()
\b0  and 
\b MKClearTrace()
\b0  return the value of the new (cumulative) trace code. \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKTranspose() 
\f1\b0 Æ
\f0  
\b See MKKeyNumToFreq() \

\fs16 \
\
\
\
\

\fs36 MKSetUGAddressArg(),  MKSetUGAddressArgToInt(), MKSetUGDatumArg, MKSetUGDatumArgLong()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Set DSP unit generator arguments\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/UnitGenerator.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 id 
\b MKSetUGAddressArg(
\b0 UnitGenerator *
\i ug
\i0 , unsigned int 
\i argNum
\i0 ,
\b  
\b0  SynthData *
\i obj
\b\i0 )\

\b0 id 
\b MKSetUGAddressArgToInt(
\b0 UnitGenerator *
\i ug
\i0 , unsigned int 
\i argNum
\i0 ,
\b  
\b0 DSPAddress 
\i address
\b\i0 )\

\b0 id 
\b MKSetUGDatumArg(
\b0 UnitGenerator *
\i ug
\i0 , unsigned int 
\i argNum
\i0 ,
\b  
\b0 DSPDatum 
\i value
\b\i0 )\

\b0 id 
\b MKSetUGDatumArgLong(
\b0 UnitGenerator *
\i ug
\i0 , unsigned int 
\i argNum
\i0 ,
\b  
\b0 DSPLongDatum *
\i value
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 These functions let you set the value of a DSP unit generator argument; they can only be called as part of the implementation of a UnitGenerator subclass.  The arguments to all four functions are similar:\

\fs16 \

\pard\tx3120\tx3620\tx4120\tx4620\fs28\fi-520\li3120\fc0\cf0 ∑	
\i ug
\i0  is the UnitGenerator object that represents the DSP unit generator; because of the nature of these functions, 
\i ug
\i0  can only be 
\b self
\b0 .\

\fs16 \

\pard\tx3120\tx3120\tx3620\tx3620\tx4120\tx4120\tx4620\tx4620\fs28\fi-520\li3120\fc0\cf0 ∑	
\i argNum
\i0  is the integer that identifies the unit generator argument that you wish to affect. \

\fs16 \

\pard\tx3120\tx3120\tx3120\tx3620\tx3620\tx3620\tx4120\tx4120\tx4120\tx4620\tx4620\tx4620\i\fs28\fi-520\li3120\fc0\cf0 ∑	
\i0 The final argument
\i  
\i0 is (or gives the address of) the value that you wish to set the unit generator argument to.\

\fs16 \

\pard\tx3120\tx3620\tx4120\b\fs28\li2620\fc0\cf0 MKSetUGAddressArg()
\b0  and 
\b MKSetUGAddressArgToInt()
\b0  are used to set address-valued unit generator arguments.  The former sets the argument to the DSP address of 
\i obj
\i0 , which must be a SynthData object.  The latter function sets it directly as the value of its 
\i address
\i0  argument.  The DSPAddress data type is defined as an 
\b int
\b0 .\

\fs16 \

\b\fs28 MKSetUGDatumArg()
\b0  and 
\b MKSetUGDatumArgLong()
\b0  set data-valued unit generator arguments.  The former takes a DSPDatum (
\b int
\b0 ) directly and sets the unit generator argument to the rightmost 24 bits of this value.  The latter is used to set 48-bit DSP values; it takes, as the 
\i value
\i0  argument, a pointer to a DSPLongDatum value.  DSPLongDatum is defined as a DSPFix48 structure:\

\fs16 \

\f3\fs24 	typedef struct _DSPFix48 \{\
		int high24;		     /* High order 24 bits, right justified */\
		int low24;		      /* Low order 24 bits, right justified */\
	\} DSPFix48;\

\fs16 \

\f0\fs28 If the argument identifed by 
\i argNum
\i0  isn't allocated in the DSP's long memory, then only the 
\b high24
\b0  field of the structure is taken as the value .\

\fs16 \

\pard\li2100\fc0\cf0 \

\fs28 RETURN\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 If 
\i argNum
\i0  is out of bounds, or if an address-setting function is used to set a data argument (or vice versa), an error is generated and 
\b nil
\b0  is returned; otherwise the 
\i ug
\i0  argument, which is always 
\b self
\b0 , is returned.  \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKUpdateAsymp()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Apply an Envelope on the DSP\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/musickit.h>\

\fs16 \

\pard\b0\fs28\fi-520\li3120\fc0\cf0 void 
\b MKUpdateAsymp(
\b0 AsympUG *
\i asymp
\i0 , Envelope *
\i envelope
\i0 , double 
\i valueAt0
\i0 , double 
\i valueAt1
\i0 , double 
\i attackDur
\i0 , double 
\i releaseDur
\i0 , double 
\i portamentoTime
\b\i0 , 
\b0 MKPhraseStatus
\i  status
\b\i0 )\

\b0\fs16\fi0\li2100 \
\

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 This is a fairly complicated function that, simply put, does the ™right thing∫ in applying an Envelope object to a DSP-synthesized musical attribute during a Music Kit performance.  It's designed to be called as part of the implementation of a SynthPatch subclass.\

\fs16 \

\fs28 The 
\i asymp
\i0  argument is an AsympUG object that will handle the Envelope on the DSP; 
\i envelope
\i0  is the Envelope object itself.  The arguments 
\i valueAt0
\i0 , 
\i valueAt1
\i0 , 
\i attackDur
\i0 , 
\i and releaseDur
\i0  scale and stretch the Envelope; their values are expected to be taken from an associated group of Note parameters.  For example, to apply an Envelope to the frequency of a synthesized Note, the values of these arguments would be retrieved as follows:\

\fs16 \

\pard\f3\fs24\li3120\fc0\cf0 Envelope *envelope = [aNote parAsEnvelope:MK_freqEnv];\
double valueAt0 = [aNote parAsDouble:MK_freq0];\
double valueAt1 = [aNote parAsDouble:MK_freq1];\
double attackDur = [aNote parAsDouble:MK_freqAtt];\
double releaseDur = [aNote parAsDouble:MK_freqRel];\
\

\pard\tx3120\tx3620\tx4120\f0\fs28\li2620\fc0\cf0 The 
\i portamentoTime
\i0  argument is taken as the Note's MK_portamentoTime value.  As the name implies, it sets the portamento or ™slur∫ between Notes and is only applied if the Note to which the Envelope belongs is a noteOn that's interrupting an existing Note.  If the note is a NoteUpdate, the value is changed abruptly.\

\fs16 \

\fs28 The final argument, 
\i status
\i0 , is used to distinguish the state of the SynthPatch at the time that the envelope is applied.  You retrieve the phrase status through SynthPatch's 
\b phraseStatus
\b0  method.  The use of portamento, for example, is determined by the value of this argument.\

\fs16 \

\fs28 The 
\i asymp
\i0  and 
\i status 
\i0 arguments are essential; the parameter-valued arguments aren't.  The function tries to be intelligent with regard to missing parameter-valued arguments; if, for example, 
\i envelope
\i0  is 
\b nil
\b0 , the value of 
\i valueAt1
\i0  is applied as a constant. .\

\fs16 \

\b\fs28 MKUpdateAsymp()
\b0  handles all the Envelope breakpoint scheduling–keep in mind that the breakpoint data in an Envelope object isn't transferred to the DSP as a unit but, instead, the breakpoints are fed to the DSP through message requests scheduled with a Conductor.  The function always schedules Envelope breakpoint messages with the clockConductor. \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 MKWritePitchNames() , MKWriteKeyNumNames()\

\fs16 \

\pard\tx4620\b0\fi-2520\li4620\fc0\cf0 \

\fs28 SUMMARY	Write pitches to a scorefile\

\fs16 \

\fs28 LIBRARY	libmusickit\

\fs16 \

\pard\fs28\li2100\fc0\cf0 SYNOPSIS\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 #import <musickit/musickit.h>\
#import <musickit/pitches.h>\

\fs16 \

\b0\fs28 void 
\b MKWritePitchNames(
\b0 BOOL 
\i yesOrNo
\i0 )\
void 
\b MKWriteKeyNumNames(
\b0 BOOL 
\i yesOrNo
\i0 )\

\fs16 \

\pard\li2100\fc0\cf0 \

\fs28 DESCRIPTION\

\pard\tx3120\tx3620\tx4120\b\li2620\fc0\cf0 MKWritePitchNames
\b0  sets the format by which frequency parameter values are written to a scorefile.  If the argument is YES, the parameter values are written as pitch name constants such as ™a4∫.  If it's NO, frequencies are written as fractional numbers.  Similarly, 
\b MKWriteKeyNumNames
\b0  controls how keyNum values are written to a scorefile.  If the argument is YES, the parameter values are written as keyNum name constants such as "a4k".  If it's NO,  key numbers are written as integers.\
\

\fs16 \

\pard\tx2100\tx2620\tx3120\tx3620\fs28\li2100\fc0\cf0 \

\fs16 \

}
