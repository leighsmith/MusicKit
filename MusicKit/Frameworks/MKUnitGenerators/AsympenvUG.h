/*
  $Id$
  
  Defined In: The MusicKit
  Description:
    See discussion. 

  Original Author: David A. Jaffe

  Copyright (c) 1996 Stanford University.
  Portions Copyright (c) 1999-2001, The MusicKit Project.
*/
// classgroup Envelope Handlers and Followers
/*!
  @class AsympenvUG
  @brief <b>AsympenvUG</b> is similar to <b>AsympUG</b>, except
  that it loads the entire envelope down to the DSP, providing better real-time performance.
  
  

AsympenvUG is an MKEnvelope handler that plays a Music Kit MKEnvelope on the DSP. It
is very similar to AsympUG and has almost the same Objective C protocol.
However, unlike AsympUG, which feeds the MKEnvelope to the DSP one segment at a
time, AsympenvUG loads the entire MKEnvelope (actually, tables derived from the
MKEnvelope data) into DSP memory. This means AsympenvUG is more well-suited to
critical interactive real-time applications, such as playing a MIDI keyboard and
hearing sound immediately. It also means that there is a limit to the length of
the envelopes it can handle, since there is a limited amount of DSP memory. In
practice, envelopes are not usually very long, so this restriction is usually
not a problem. In short, it is usually best to use AsympenvUG if critical
interactive real-time is a concern, but AsympUG is better for situations with
very long Envelopes or where real-time response is not an issue.

AsympenvUG objects are normally used to provide dynamic scaling of a musical
attribute.  To this end, the output of an AsympenvUG is typically connected to
the frequency or amplitude input of an OscgafiUG object or used as input to an
InterpUG, Mul2UG, ScaleUG, etc. Although typically used to convey Envelopes,
AsympUG may also be used as a simple exponential ramper, without an explicit
MKEnvelope object. Methods are provided that let you set the rate directly, or as
a time limit (referred to as  &ldquo;T60&rdquo;) that defines when the target
will have been perceptually reached.  

For each MKEnvelope segment, AsympenvUG creates an exponential signal that
approaches a limit (the &ldquo;target&rdquo;) at a particular rate, where the
rate expresses the precentage of the remaining journey that's taken with each
step:
	
<i>output</i> = <i>previousOutput</i> + (<i>rate</i> * (<i>target - 
previousOutput</i>))	
<i>previousOutput</i> = <i>output</i>

For example, if the rate is 0.1 and the target is 1.0, the samples generated by
the AsympUG are
	
0.1, 0.19, 0.271, 0.343, 0.409, 0.4685, ...

Exponential envelopes have the advantage of being "self-limiting". That is, 
they seek their targets from any starting point. This allows for efficient
implementation of long connected MKEnvelope "phrases", one of the primary
advantages of the Music Kit's Note representation. In addition, if, for some
reason, the host processor gets a little bit behind, due to time-sharing, the
envelope will not continue unbounded toward disaster. 
 
MKEnvelope data is mapped onto the exponential representation as
follows:

The Envelope's yArray[n] is the target, considered to be in the infinite
future.The Envelope's xArray[n] is the time of the right-hand side of the
segment (i.e. the time to interrupt the trajectory toward yArray[n]). The
Envelope's smoothingArra[n] is the smoothing constant to get to yArray[n]. If
smoothingArra[n] is 0, the point  is reached immediately. If smoothingArra[n] is
1.0, the point is reached,  within about -48dB at the time of the next update.
If smoothingArra[n] is larger, the point is not reached within -48dB by the time
of the next update. A value of smoothingArra[n] of infinity will cause the
envelope to never change value. The first point, xArray[0], is assumed to be the
right-hand side of the non-existant first segment. yArray[0] is the initial
point (which may or may not be used, depending on the value of the instance
variable useInitialvalue (see below)). smoothingArra[0] is ignored. 

The envelope has a "stick point". When the envelope handler reaches the stick
point, it does not proceed to the next point until it receives the
<b>-finish</b> message. If there is no stick point, the <b>-finish</b> message
is ignored. If the envelope handler has not yet reached the stick point when the
<b>-finish</b> message is received, the envelope handler proceeds to the first
point after the stick point and continues from there.  

Music Kit Envelopes are usually associated with a set of parameters, such as
attackTime, releaseTime, etc. The C function <b>MKUpdateAsymp()</b> is provided
to conveniently manage setting the AsympUG's attributes according to a given
MKEnvelope and a set of Note parameters. By using <b>MKUpdateAsymp()</b>, you need
only set the AsympenvUG's output patchpoint; all other methods are invoked for
you.  For more information, see the Class Description for the MKEnvelope
class.

As with AsympUG, you should not change the contents of a Music Kit MKEnvelope
object while an AsympenvUG is using it. Furthermore, MKEnvelope data is cached on
the DSP and referenced using the MKEnvelope object id for speed and efficiency.
This has the advantage of allowing several AsympenvUGs to share MKEnvelope data
and avoids wasting DSP memory. However, this also implies that if you change the
data in an MKEnvelope object, these changes may not take effect, because the Music
Kit continues to use the old representation. Therefore, if you do change an
MKEnvelope's data, you should send the message <b>+envelopeHasChanged:</b>,
passing the MKEnvelope object as the argument. Also, you should not free any
MKEnvelope objects that have been used in a Music Kit performance until the
MKOrchestra has been closed. Otherwise, a re-used id may cause the AsympenvUG to
use an incorrect cached MKEnvelope.

There are a few other differences between AsympUG and AsympenvUG:

<ul>
<li> The methods <b>-setYScale:yOffset:</b> and <b>-setReleaseXScale:</b> have
no effect. They are included only for compatability with <b>MKUpdateAsymp()</b>.
This implies that it is not possible to change the scale and offset of an
MKEnvelope that is in progress.

<li> TransitionTime, which is specified in the method 
-<b>resetEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:transitionTime:</b>, is currently ignored.
It is included only for compatability with <b>MKUpdateAsymp()</b>.
</ul>
 
<h2>Memory Spaces</h2>

<b>AsympenvUG<i>a</i></b>
<i>a</i>	output 
*/

#import <MusicKit/MusicKit.h>

@interface AsympenvUG : MKUnitGenerator
{
    id anEnv;
    double (*scalingFunc)(); 
    double timeScale;            
    double releaseTimeScale;      
    double yScale;                
    double yOffset;               
    double targetX;               
    char useInitialValue;         
    int stickPoint; 
    DSPDatum firstVal;
    double releaseTime;
    double envTriggerTime;
    MKSynthData *durMem,*targetMem,*rateMem; 
    double _transitionTime;
    double _samplingRate;
    double _smoothConstant;
    int _tickRate;
}

+(void)envelopeHasChanged:(MKEnvelope *)env;  
+(void)freeKeyObjects; 

/*!
  @param  aPatchpoint is an id.
  @return Returns an id.
  @brief Sets the output patchpoint to <i>aPatchpoint</i>.

  Returns
  <b>self</b>, or <b>nil</b> if the argument isn't a
  patchpoint.
*/
-setOutput:aPatchPoint;

/*!
  @param  (double)target is an id.
  @return Returns <b>self</b>.
  @brief Sets the target to <i>target</i>, which should be between 0.0 and
  1.0.

  The new target is simply inserted, overriding the current
  target.  If the object is already  processing an envelope, that
  envelope is not interrupted. 
*/
-setTargetVal:(double)aVal;

/*!
  @param  (double)value is an id.
  @return Returns <b>self</b>.
  @brief Sets the current value of the AsympenvUG to <i>value</i>.

  The new
  value overrides the previous sample as shown in the computation in
  the class description above.  If the object is already  processing
  an envelope, that envelope is not interrupted.  
*/
-setCurVal:(double)aVal;

/*!
  @param  (double)rate is an id.
  @return Returns <b>self</b>.
  @brief Sets the rate at which the AsympenvUG approaches its target, where
  <i>rate</i> is the percentage of the remaining journey that's
  stepped off at each sample.

  The value of <i>rate</i>, which should
  be between 0.0 and 0.125.  (It should be between 0.0 and 1.0, but
  for historical reasons the outer limit stands at 0.125.  In any
  case, a rate of 0.125 means that the target is virtually reached in
  less than two ticks, which is quite fast).  More precisely, this
  method sets the rate of the exponential. (1-e^T/tau), where T is
  sampling period and tau is the time constant.If the AsympenvUG is
  already processing an MKEnvelope, the new rate is simply inserted,
  overriding the current value, and the MKEnvelope proceeds otherwise
  unaffected.  
  
  @see <b>- setT60:</b>
*/
-setRate:(double)aVal;

/*!
  @param  (double)seconds is an id.
  @return Returns <b>self</b>.
  @brief Computes the AsynpUG's rate such that the target is perceptually
  reached (to within -60dB of the target) in <i>seconds</i> seconds.

  
  
  
  @see <b>- setRate:</b>
*/
-setT60:(double)seconds;

/*!
  @return Returns an id.
  @brief Causes the AsympenvUG to head for the last breakpoint in its
  MKEnvelope, using a rate that's computed from the value set through
  the <b>MKSetPreemptDuration()</b> function (the default preempt
  duration is 0.006 seconds).

  This method is invoked automatically by
  a SynthInstrument object when it preempts a MKSynthPatch that
  contains AsympenvUG objects.
*/
-preemptEnvelope;

/*!
  @param  anEnvelope is an id.
  @param  yScaleValue is a double.
  @param  yOffsetValue is a double.
  @param  xScaleValue is a double.
  @param  releaseXScaleValue is a double.
  @param  yScaleFunction is a pointer to a function returning a double (double(*)()).
  @return Returns an id.
  @brief Associates the AsympenvUG with the given MKEnvelope and arguments.

  
  When the AsympenvUG is run, it automatically schedules the
  breakpoints from its MKEnvelope to be fed to itself through message
  requests with the clockConductor.  If this method is invoked while
  the AsympenvUG is running, the object's current value is immediately
  set to the (scaled and offset) y value of the first breakpoint in
  the new MKEnvelope.   When continuity is desired with the previous
  invocation, use the <b>resetEnvelope:...</b> method instead.
  
  The <i>yScaleValue</i> and <i>yOffsetValue</i>
  arguments scale and offset the AsympenvUG target values as each
  breakpoint is reached;  <i>xScaleValue</i> and <i>releaseXScaleValue</i>
  modify the rate before and after the MKEnvelope's stickpoint is reached, respectively.  
  
  The <i>yScaleFunction</i> argument is a pointer to an
  optional function that performs additional, possibly dynamic, target
  scaling.  The fuction takes two arguments, a <b>double</b> that
  gives the AsympenvUG's current value, and the object's <b>id</b>. 
  The function is called once for each breakpoint.  
  
  Typically, you call the <b>MKUpdateAsymp()</b>
  function rather than invoking this method.  The function provides a
  slightly easier interface to AsympenvUG management in the context of
  a MKSynthPatch.  
*/
- setEnvelope:anEnvelope
       yScale:(double)yScaleValue
      yOffset:(double)yOffsetValue
       xScale:(double)xScaleValue
releaseXScale:(double)releaseXScaleValue
      funcPtr:(double(*)())yScaleFunction;
 
/*!
  @param  anEnvelope is an id.
  @param  yScaleValue is a double.
  @param  yOffsetValue is a double.
  @param  xScaleValue is a double.
  @param  releaseXScaleValue is a double.
  @param  yScaleFunction is a pointer to a function returning a double (double(*)()).
  @param  transitionTime is a double.
  @return Returns an id.
  @brief This method is similar to the <b>setEnvelope:...</b> method but for
  this difference:  If the AsympenvUG is running, its current value
  isn't reset to the new MKEnvelope's first y value; instead, the new
  MKEnvelope's first breakpoint is ignored and the Asymp's rate is
  reset such that it proceeds toward the second breakpoint.

  This
  affords are more graceful transition into the new MKEnvelope. 
  <i>transitionTime</i>is currently ignored. As with the
  <b>setEnvelope:...</b>  method, you typically call the
  <b>MKUpdateAsymp()</b> function rather than invoke this
  method.
*/
-resetEnvelope:anEnvelope
        yScale:(double)yScaleValue
       yOffset:(double)yOffsetValue
        xScale:(double)xScaleValue
 releaseXScale:(double)releaseXScaleValue
       funcPtr:(double(*)())yScaleFunction
transitionTime:(double)transitionTime;

/*!
  @param  yesOrNo is a BOOL.
  @return Returns an id.
  @brief Controls how the MKEnvelope is handled when it is "retriggered"
  (i.e.

  <b>run</b> is invoked before the preceeding MKEnvelope has
  finished.) If <i>yesOrNo</i>, the first value of the MKEnvelope is
  set as the AsympenvUG's first output. Otherwise, the AsympenvUG
  continues from whatever its current value happens to be to the
  second point of the MKEnvelope. This method is rarely needed, since
  the same functionality is provided by <b>resetEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:transitionTime:</b>. It is included as an optimization, when it is known that all parameters are the same.
*/
-useInitialValue:(BOOL)yesOrNo;

/*!
  @param  yScaleValue is a double.
  @param  yOffsetValue is a double.
  @return Returns <b>self</b>.
  @brief Has no effect.

  Implemented for compatability with <b>AsympUG</b>. 
  
*/
-setYScale:(double)yScaleVal yOffset:(double)yOffsetVal;

/*!
  @param  releaseXScaleValue is a double.
  @return Returns <b>self</b>.
  @brief Has no effect.

  Implemented for compatability with <b>AsympUG</b>. 
  
*/
-setReleaseXScale:(double)rXScaleVal ;

/*!
  @return Returns an id.
  @brief Returns the MKEnvelope that's associated with the AsympenvUG, or
  <b>nil</b> if none.

  
*/
-envelope;

/*!
  @return Returns <b>self</b>.
  @brief You never send this message.

  It's invoked by sending the <b>run</b>
  message to the object.  Starts the MKEnvelope, if any, on its way. 
  
*/
-runSelf;
-abortSelf;

/*!
  @return Returns an id.
  @brief You never send this message.

  It's invoked by sending the
  <b>idle</b>message to the object.  
  Sets the output patchpoint to <i>sink</i>,<i></i> thus ensuring
  that the object does not produce any output.  Note that you must
  send <b>setOutput:</b> and <b>run</b> again to use the
  MKUnitGenerator after sending <b>idle</b>.
*/
-idleSelf;

/*!
  @return Returns a double.
  @brief You never invoke this method; it's invoked automatically when the
  AsympenvUG receives the <b>finish</b> message.

  If the object has
  yet to see or is waiting at its MKEnvelope's stickpoint, this causes
  it to head for the first breakpoint after the stickpoint, and then
  on the end of the MKEnvelope.  If the AsympenvUG's MKEnvelope
  contains no stickpoint, this method has no effect. Returns the time
  in seconds until the MKEnvelope is expected to finish, plus a small
  grace time given by <b>MKGetPreemptDuration()</b>. This time may be
  changed by calling  <b>MKSetPreemptDuration()</b>.
*/
-(double)finishSelf;

/*!
  @param arg is an unsigned.
  @return Returns an BOOL.
  @brief Specifies that all arguments are to be optimized if possible except the
  state variable.

  
*/
+(BOOL)shouldOptimize:(unsigned) arg;

/*!
  @return Returns <b>self</b>.
  @brief Disassociates the AsympenvUG from its MKEnvelope.

  The MKEnvelope
  sticks on its current value.  
*/
-abortEnvelope;

/*!
  @param  val is a double.
  @return Returns an id.
  @brief Aborts any running MKEnvelope and sets the AsympenvUG to produce
  <i>val</i> as a constant value.

  Equivalent to invoking
  <b>abortEnvelope</b>, followed by <b>setTarget:</b><i>val</i>,
  followed by <b>setCurVal:</b><i>val</i>.
*/
-setConstant:(double)aVal;

extern id MKAsympUGxClass(void);
extern id MKAsympUGyClass(void);
extern void
  MKUpdateAsymp(id asymp, id envelope, double val0, double val1,
		double attDur, double relDur, double portamentoTime,
		MKPhraseStatus status);

@end

